{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"stream-unzip","text":"<p>Python function to stream unzip all the files in a ZIP archive, without loading the entire ZIP file into memory or any of its uncompressed files.</p> <p>To create ZIP files on the fly try stream-zip.</p>"},{"location":"#features","title":"Features","text":"<p>In addition to being memory efficient, stream-unzip supports:</p> <ul> <li> <p>Deflate-compressed ZIPs. The is the historical standard for ZIP files.</p> </li> <li> <p>Deflate64-compressed ZIPs. These are created by certain versions of Windows Explorer in some circumstances. Python's zipfile module cannot open Deflate64-compressed ZIPs.</p> </li> <li> <p>Zip64 ZIP files. These are ZIP files that allow sizes far beyond the approximate 4GiB limit of the original ZIP format.</p> </li> <li> <p>WinZip-style AES-encrypted ZIPs. Python's zipfile module cannot open AES-encrypted ZIPs.</p> </li> <li> <p>Legacy-encrypted ZIP files. This is also known as ZipCrypto/Zip 2.0.</p> </li> <li> <p>ZIP files created by Java's ZipOutputStream that are larger than 4GiB. At the time of writing libarchive-based stream readers cannot read these without error.</p> </li> <li> <p>BZip2-compressed ZIPs.</p> </li> </ul> <p>Visit Getting started to get started.</p>"},{"location":"contributing/","title":"How to contribute","text":"<p>In most cases to contribute you will need a GitHub account.</p>"},{"location":"contributing/#contributing-an-issue","title":"Contributing an issue","text":"<p>Suspected issues with stream-unzip can be submitted at the stream-unzip Issues page.</p> <p>An issue that contains a minimal, reproducible example stands the best chance of being resolved. However, it is understood that this is not possible in all circumstances.</p>"},{"location":"contributing/#contributing-a-feature-request","title":"Contributing a feature request","text":"<p>A feature request can be submitted using the Ideas category in the stream-unzip discussions.</p>"},{"location":"contributing/#contributing-documentation-or-code","title":"Contributing documentation or code","text":"<p>To contribute changes to documentation or code, you will need the source of stream-unzip locally. The instructions for this depend on if you are a member of the uktrade GitHub organisation. In both cases, experience of working with source code, working on the command line, and working with git is helpful.</p>"},{"location":"contributing/#if-youre-a-member-of-uktrade","title":"If you're a member of uktrade","text":"<ol> <li> <p>Setup an SSH key and associate it with your GitHub account</p> </li> <li> <p>Clone the repository</p> <pre><code>git clone git@github.com:uktrade/stream-unzip.git\ncd stream-zup\n</code></pre> </li> </ol> <p>You should not fork the repository if you're a member of uktrade.</p>"},{"location":"contributing/#if-youre-not-a-member-of-uktrade","title":"If you're not a member of uktrade","text":"<ol> <li> <p>Setup an SSH key and associate it with your GitHub account.</p> </li> <li> <p>Clone the repository.</p> <pre><code>git clone git@github.com:/stream-unzip.git\ncd stream-zup\n</code></pre> </li> <li> <p>Fork the repository. Make a note of the \"Owner\" that you fork to. This is usually your username.</p> <p>There is more documentation on forking in GitHub's guide on contributing to projects.</p> </li> <li> <p>Clone the forked repository. In the following, replace <code>my-username</code> with the owner that you forked to in step 2.</p> <pre><code>git clone git@github.com:my-username/stream-unzip.git\ncd stream-zup\n</code></pre> </li> </ol>"},{"location":"contributing/#contributing-documentation","title":"Contributing documentation","text":"<p>The source of the documentation is in the docs/ directory of the source code, and is written using Material for mkdocs.</p> <p>Changes are then submitted via a Pull Request (PR). To do this:</p> <ol> <li> <p>Decide on a short hyphen-separated descriptive name for your change, prefixed with <code>docs/</code> for example <code>docs/add-example</code>.</p> </li> <li> <p>Make a branch using this descriptive name.</p> <pre><code>git checkout -b docs/add-example\ncd stream-unzip\n</code></pre> </li> <li> <p>Make your changes in a text editor.</p> </li> <li> <p>Preview your changes locally.</p> <pre><code>pip install -r requirements-docs.txt  # Only needed once\nmkdocs serve\n</code></pre> </li> <li> <p>Commit your change and push to your fork. Ideally the commit message will follow the Conventional Commit specification.</p> <pre><code>git add docs/getting-started.md  # Repeat for each file changed\ngit commit -m \"docs: add an example\"\ngir push origin docs/add-example\n</code></pre> </li> <li> <p>Raise a PR at https://github.com/uktrade/stream-unzip/pulls against the <code>main</code> branch in stream-unzip.</p> </li> <li> <p>Wait for the PR to be approved and merged, and respond to any questions or suggested changes.</p> </li> </ol> <p>When the PR is merged, the documentation is deployed automatically to https://stream-unzip.docs.trade.gov.uk/.</p>"},{"location":"contributing/#contributing-code","title":"Contributing code","text":"<p>To contribute most code changes:</p> <ul> <li> <p>Knowledge of Python is required. Python iterables, and specifically generators, are used heavily in stream-unzip.</p> </li> <li> <p>Understanding the low-level properties of the ZIP file format is required. These are covered in detail in the specification of the ZIP file format, known as APPNOTE.</p> </li> </ul> <p>APPNOTE can be difficult to read, and contains a lot of information that isn't needed for stream-unzip. A more concise introduction is in the Wikipedia page on the ZIP file format. However the Wikipedia page is less authoritative.</p> <p>In both APPNOTE and the Wikipedia page, the most relevant parts are about the \"local file header\" and the \"data descriptor\". These are sections of metadata that go before and after the contents of each file respectively.</p> <p>Changes are then submitted via a Pull Request (PR). To do this:</p> <ol> <li> <p>Decide on a short hyphen-separated descriptive name for your change, prefixed with the type of change. For example <code>fix/the-bug-description</code>.</p> </li> <li> <p>Make a branch using this descriptive name.</p> <pre><code>git checkout -b fix-a-bug-description\n</code></pre> </li> <li> <p>Make sure you can run existing tests locally</p> <pre><code>pip install -r requirements-dev.txt  # Only needed once\npytest\n</code></pre> </li> <li> <p>Make your changes in a text editor. In the cases of changing behaviour, this would usually include changing or adding at least one test in test_stream_zip.py, and running them.</p> <pre><code>pytest\n</code></pre> </li> <li> <p>Commit your changes and push to your fork. Ideally the commit message will follow the Conventional Commit specification.</p> <pre><code>git add stream_zip.py  # Repeat for each file changed\ngit commit -m \"feat: the bug description\"\ngir push origin fix/the-bug-description\n</code></pre> </li> <li> <p>Raise a PR at https://github.com/uktrade/stream-unzip/pulls against the <code>main</code> branch in stream-unzip.</p> </li> <li> <p>Wait for the PR to be approved and merged, and respond to any questions or suggested changes.</p> </li> </ol>"},{"location":"exceptions/","title":"Exceptions","text":"<p>Exceptions raised by the source iterable are passed through <code>stream_unzip</code> unchanged. Other exceptions are in the <code>stream_unzip</code> module, and derive from its <code>UnzipError</code>.</p>"},{"location":"exceptions/#exception-hierarchy","title":"Exception hierarchy","text":"<ul> <li> <p>UnzipError</p> <p>Base class for all explicitly-thrown exceptions</p> <ul> <li> <p>InvalidOperationError</p> <ul> <li> <p>UnfinishedIterationError</p> <p>The unzipped chunks iterator of a member file has not been iterated to completion.</p> </li> </ul> </li> <li> <p>UnzipValueError (also inherits from the ValueError built-in)</p> <p>Base class for errors relating to invalid arguments</p> <ul> <li> <p>PasswordError</p> <ul> <li> <p>MissingPasswordError</p> <p>A file requires a password, but it was not supplied.</p> <ul> <li> <p>MissingZipCryptoPasswordError</p> <p>A file is legacy (ZipCrypto/Zip 2.0) encrypted, but a password was not supplied.</p> </li> <li> <p>MissingAESPasswordError</p> <p>A file is AES encrypted, but a password was not supplied.</p> </li> </ul> </li> <li> <p>IncorrectPasswordError</p> <p>An incorrect password was supplied. Note that due to nature of the ZIP file format, some incorrect passwords would not raise this exception, and instead raise a <code>DataError</code>, or even in pathalogical cases, not raise any exception.</p> <ul> <li> <p>IncorrectZipCryptoPasswordError</p> <p>An incorrect password was supplied for a legacy (ZipCrypto/Zip 2.0) encrypted file.</p> </li> <li> <p>IncorrectAESPasswordError</p> <p>An incorrect password was supplied for an AES encrypted file.</p> </li> </ul> </li> </ul> </li> <li> <p>DataError</p> <p>An issue with the ZIP bytes themselves was encountered.</p> <ul> <li> <p>UnsupportedFeatureError</p> <p>A file in the ZIP uses features that are unsupported.</p> <ul> <li> <p>UnsupportedFlagsError</p> </li> <li> <p>UnsupportedCompressionTypeError</p> </li> <li> <p>UnsupportedZip64Error</p> </li> </ul> <p>A Zip64 member file has been encounted but support has been disabled.</p> </li> <li> <p>UncompressError</p> </li> <li> <p>BZ2Error</p> <p>An error in the bz2-compressed data meant it could not be decompressed.</p> </li> <li> <p>DeflateError</p> <p>An error in the deflate-compressed data meant it could not be decompressed.</p> </li> <li> <p>IntegrityError</p> <ul> <li> <p>HMACIntegrityError</p> <p>The HMAC integrity check on AES encrypted bytes failed</p> </li> <li> <p>CRC32IntegrityError</p> <p>The CRC32 integrity check on decrypted and decompressed bytes failed.</p> </li> </ul> </li> <li> <p>SizeIntegrityError</p> <ul> <li> <p>UncompressedSizeIntegrityError</p> <p>The amount of uncompressed bytes of a member file did not match its metadata.</p> </li> <li> <p>CompressedSizeIntegrityError</p> <p>The amount of compressed bytes of a member file did not match its metadata.</p> </li> </ul> </li> <li> <p>TruncatedDataError</p> <p>The stream of bytes ended unexpectedly.</p> </li> <li> <p>UnexpectedSignatureError</p> <p>Each section of a ZIP file starts with a signature, and an unexpected one was encountered.</p> </li> <li> <p>MissingExtraError</p> <p>Metadata known as extra that some ZIP files require is missing.</p> <ul> <li>MissingAESExtraError</li> </ul> </li> <li> <p>TruncatedExtraError</p> <p>Metadata known as extra that some ZIP files require is present, but too short.</p> <ul> <li> <p>TruncatedZip64ExtraError</p> </li> <li> <p>TruncatedAESExtraError</p> </li> </ul> </li> <li> <p>InvalidExtraError</p> <p>Metadata known as extra that some ZIP files require is present, long enough, but holds an invalid value.</p> <ul> <li> <p>InvalidAESKeyLengthError</p> <p>AES key length specified in the ZIP is not any of 1, 2, or 3 (which correspond to 128, 192, and 256 bits respectively).</p> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Python 3.5+</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install stream-unzip and its dependencies from PyPI using pip.</p> <pre><code>pip install stream-unzip\n</code></pre> <p>This installs the latest version of stream-unzip, and the latest compatible version of all of its dependencies.</p> <p>If you regularly install stream-unzip, such as during application deployment, to avoid unexpected changes as new versions are released, you can pin to specific versions. Poetry or pip-tools are popular tools that can be used for this.</p>"},{"location":"getting-started/#usage","title":"Usage","text":"<p>A single function is exposed, <code>stream_unzip</code>, that takes a single argument: an iterable that should yield the bytes of a ZIP file [with no zero-length chunks]. It returns an iterable, where each yielded item is a tuple of the file name, file size [<code>None</code> if this is not known], and another iterable itself yielding the unzipped bytes of that file.</p> <pre><code>from stream_unzip import stream_unzip\nimport httpx\ndef zipped_chunks():\n# Iterable that yields the bytes of a zip file\nwith httpx.stream('GET', 'https://www.example.com/my.zip') as r:\nyield from r.iter_bytes(chunk_size=65536)\nfor file_name, file_size, unzipped_chunks in stream_unzip(zipped_chunks(), password=b'my-password'):\n# unzipped_chunks must be iterated to completion or UnfinishedIterationError will be raised\nfor chunk in unzipped_chunks:\nprint(chunk)\n</code></pre> <p>The file name and file size are extracted as reported from the file. If you don't trust the creator of the ZIP file, these should be treated as untrusted input.</p>"}]}